// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vcd

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type IndependentDisk struct {
	pulumi.CustomResourceState

	// Set of VM IDs which are using the disk
	AttachedVmIds pulumi.StringArrayOutput `pulumi:"attachedVmIds"`
	BusSubType    pulumi.StringOutput      `pulumi:"busSubType"`
	BusType       pulumi.StringOutput      `pulumi:"busType"`
	// Datastore name
	DatastoreName pulumi.StringOutput `pulumi:"datastoreName"`
	// independent disk description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// True if disk is encrypted
	Encrypted pulumi.BoolOutput `pulumi:"encrypted"`
	// IOPS request for the created disk
	Iops pulumi.IntOutput `pulumi:"iops"`
	// True if the disk is already attached
	IsAttached pulumi.BoolOutput `pulumi:"isAttached"`
	// Key value map of metadata to assign to this disk. Key and value can be any string.
	//
	// Deprecated: Use metadata_entry instead
	Metadata pulumi.MapOutput `pulumi:"metadata"`
	// Metadata entries for the given Disk
	MetadataEntries IndependentDiskMetadataEntryArrayOutput `pulumi:"metadataEntries"`
	Name            pulumi.StringOutput                     `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrOutput `pulumi:"org"`
	// The owner name of the disk
	OwnerName pulumi.StringOutput `pulumi:"ownerName"`
	// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
	SharingType pulumi.StringOutput `pulumi:"sharingType"`
	// size in MB
	SizeInMb       pulumi.IntOutput    `pulumi:"sizeInMb"`
	StorageProfile pulumi.StringOutput `pulumi:"storageProfile"`
	// The UUID of this named disk's device backing
	Uuid pulumi.StringOutput `pulumi:"uuid"`
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrOutput `pulumi:"vdc"`
}

// NewIndependentDisk registers a new resource with the given unique name, arguments, and options.
func NewIndependentDisk(ctx *pulumi.Context,
	name string, args *IndependentDiskArgs, opts ...pulumi.ResourceOption) (*IndependentDisk, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SizeInMb == nil {
		return nil, errors.New("invalid value for required argument 'SizeInMb'")
	}
	var resource IndependentDisk
	err := ctx.RegisterResource("vcd:index/independentDisk:IndependentDisk", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIndependentDisk gets an existing IndependentDisk resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIndependentDisk(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IndependentDiskState, opts ...pulumi.ResourceOption) (*IndependentDisk, error) {
	var resource IndependentDisk
	err := ctx.ReadResource("vcd:index/independentDisk:IndependentDisk", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IndependentDisk resources.
type independentDiskState struct {
	// Set of VM IDs which are using the disk
	AttachedVmIds []string `pulumi:"attachedVmIds"`
	BusSubType    *string  `pulumi:"busSubType"`
	BusType       *string  `pulumi:"busType"`
	// Datastore name
	DatastoreName *string `pulumi:"datastoreName"`
	// independent disk description
	Description *string `pulumi:"description"`
	// True if disk is encrypted
	Encrypted *bool `pulumi:"encrypted"`
	// IOPS request for the created disk
	Iops *int `pulumi:"iops"`
	// True if the disk is already attached
	IsAttached *bool `pulumi:"isAttached"`
	// Key value map of metadata to assign to this disk. Key and value can be any string.
	//
	// Deprecated: Use metadata_entry instead
	Metadata map[string]interface{} `pulumi:"metadata"`
	// Metadata entries for the given Disk
	MetadataEntries []IndependentDiskMetadataEntry `pulumi:"metadataEntries"`
	Name            *string                        `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org *string `pulumi:"org"`
	// The owner name of the disk
	OwnerName *string `pulumi:"ownerName"`
	// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
	SharingType *string `pulumi:"sharingType"`
	// size in MB
	SizeInMb       *int    `pulumi:"sizeInMb"`
	StorageProfile *string `pulumi:"storageProfile"`
	// The UUID of this named disk's device backing
	Uuid *string `pulumi:"uuid"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
}

type IndependentDiskState struct {
	// Set of VM IDs which are using the disk
	AttachedVmIds pulumi.StringArrayInput
	BusSubType    pulumi.StringPtrInput
	BusType       pulumi.StringPtrInput
	// Datastore name
	DatastoreName pulumi.StringPtrInput
	// independent disk description
	Description pulumi.StringPtrInput
	// True if disk is encrypted
	Encrypted pulumi.BoolPtrInput
	// IOPS request for the created disk
	Iops pulumi.IntPtrInput
	// True if the disk is already attached
	IsAttached pulumi.BoolPtrInput
	// Key value map of metadata to assign to this disk. Key and value can be any string.
	//
	// Deprecated: Use metadata_entry instead
	Metadata pulumi.MapInput
	// Metadata entries for the given Disk
	MetadataEntries IndependentDiskMetadataEntryArrayInput
	Name            pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrInput
	// The owner name of the disk
	OwnerName pulumi.StringPtrInput
	// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
	SharingType pulumi.StringPtrInput
	// size in MB
	SizeInMb       pulumi.IntPtrInput
	StorageProfile pulumi.StringPtrInput
	// The UUID of this named disk's device backing
	Uuid pulumi.StringPtrInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
}

func (IndependentDiskState) ElementType() reflect.Type {
	return reflect.TypeOf((*independentDiskState)(nil)).Elem()
}

type independentDiskArgs struct {
	BusSubType *string `pulumi:"busSubType"`
	BusType    *string `pulumi:"busType"`
	// independent disk description
	Description *string `pulumi:"description"`
	// Key value map of metadata to assign to this disk. Key and value can be any string.
	//
	// Deprecated: Use metadata_entry instead
	Metadata map[string]interface{} `pulumi:"metadata"`
	// Metadata entries for the given Disk
	MetadataEntries []IndependentDiskMetadataEntry `pulumi:"metadataEntries"`
	Name            *string                        `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org *string `pulumi:"org"`
	// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
	SharingType *string `pulumi:"sharingType"`
	// size in MB
	SizeInMb       int     `pulumi:"sizeInMb"`
	StorageProfile *string `pulumi:"storageProfile"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
}

// The set of arguments for constructing a IndependentDisk resource.
type IndependentDiskArgs struct {
	BusSubType pulumi.StringPtrInput
	BusType    pulumi.StringPtrInput
	// independent disk description
	Description pulumi.StringPtrInput
	// Key value map of metadata to assign to this disk. Key and value can be any string.
	//
	// Deprecated: Use metadata_entry instead
	Metadata pulumi.MapInput
	// Metadata entries for the given Disk
	MetadataEntries IndependentDiskMetadataEntryArrayInput
	Name            pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrInput
	// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
	SharingType pulumi.StringPtrInput
	// size in MB
	SizeInMb       pulumi.IntInput
	StorageProfile pulumi.StringPtrInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
}

func (IndependentDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*independentDiskArgs)(nil)).Elem()
}

type IndependentDiskInput interface {
	pulumi.Input

	ToIndependentDiskOutput() IndependentDiskOutput
	ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput
}

func (*IndependentDisk) ElementType() reflect.Type {
	return reflect.TypeOf((**IndependentDisk)(nil)).Elem()
}

func (i *IndependentDisk) ToIndependentDiskOutput() IndependentDiskOutput {
	return i.ToIndependentDiskOutputWithContext(context.Background())
}

func (i *IndependentDisk) ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskOutput)
}

// IndependentDiskArrayInput is an input type that accepts IndependentDiskArray and IndependentDiskArrayOutput values.
// You can construct a concrete instance of `IndependentDiskArrayInput` via:
//
//	IndependentDiskArray{ IndependentDiskArgs{...} }
type IndependentDiskArrayInput interface {
	pulumi.Input

	ToIndependentDiskArrayOutput() IndependentDiskArrayOutput
	ToIndependentDiskArrayOutputWithContext(context.Context) IndependentDiskArrayOutput
}

type IndependentDiskArray []IndependentDiskInput

func (IndependentDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndependentDisk)(nil)).Elem()
}

func (i IndependentDiskArray) ToIndependentDiskArrayOutput() IndependentDiskArrayOutput {
	return i.ToIndependentDiskArrayOutputWithContext(context.Background())
}

func (i IndependentDiskArray) ToIndependentDiskArrayOutputWithContext(ctx context.Context) IndependentDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskArrayOutput)
}

// IndependentDiskMapInput is an input type that accepts IndependentDiskMap and IndependentDiskMapOutput values.
// You can construct a concrete instance of `IndependentDiskMapInput` via:
//
//	IndependentDiskMap{ "key": IndependentDiskArgs{...} }
type IndependentDiskMapInput interface {
	pulumi.Input

	ToIndependentDiskMapOutput() IndependentDiskMapOutput
	ToIndependentDiskMapOutputWithContext(context.Context) IndependentDiskMapOutput
}

type IndependentDiskMap map[string]IndependentDiskInput

func (IndependentDiskMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndependentDisk)(nil)).Elem()
}

func (i IndependentDiskMap) ToIndependentDiskMapOutput() IndependentDiskMapOutput {
	return i.ToIndependentDiskMapOutputWithContext(context.Background())
}

func (i IndependentDiskMap) ToIndependentDiskMapOutputWithContext(ctx context.Context) IndependentDiskMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndependentDiskMapOutput)
}

type IndependentDiskOutput struct{ *pulumi.OutputState }

func (IndependentDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskOutput) ToIndependentDiskOutput() IndependentDiskOutput {
	return o
}

func (o IndependentDiskOutput) ToIndependentDiskOutputWithContext(ctx context.Context) IndependentDiskOutput {
	return o
}

// Set of VM IDs which are using the disk
func (o IndependentDiskOutput) AttachedVmIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringArrayOutput { return v.AttachedVmIds }).(pulumi.StringArrayOutput)
}

func (o IndependentDiskOutput) BusSubType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.BusSubType }).(pulumi.StringOutput)
}

func (o IndependentDiskOutput) BusType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.BusType }).(pulumi.StringOutput)
}

// Datastore name
func (o IndependentDiskOutput) DatastoreName() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.DatastoreName }).(pulumi.StringOutput)
}

// independent disk description
func (o IndependentDiskOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// True if disk is encrypted
func (o IndependentDiskOutput) Encrypted() pulumi.BoolOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.BoolOutput { return v.Encrypted }).(pulumi.BoolOutput)
}

// IOPS request for the created disk
func (o IndependentDiskOutput) Iops() pulumi.IntOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.IntOutput { return v.Iops }).(pulumi.IntOutput)
}

// True if the disk is already attached
func (o IndependentDiskOutput) IsAttached() pulumi.BoolOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.BoolOutput { return v.IsAttached }).(pulumi.BoolOutput)
}

// Key value map of metadata to assign to this disk. Key and value can be any string.
//
// Deprecated: Use metadata_entry instead
func (o IndependentDiskOutput) Metadata() pulumi.MapOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.MapOutput { return v.Metadata }).(pulumi.MapOutput)
}

// Metadata entries for the given Disk
func (o IndependentDiskOutput) MetadataEntries() IndependentDiskMetadataEntryArrayOutput {
	return o.ApplyT(func(v *IndependentDisk) IndependentDiskMetadataEntryArrayOutput { return v.MetadataEntries }).(IndependentDiskMetadataEntryArrayOutput)
}

func (o IndependentDiskOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
// different organizations
func (o IndependentDiskOutput) Org() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Org }).(pulumi.StringPtrOutput)
}

// The owner name of the disk
func (o IndependentDiskOutput) OwnerName() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.OwnerName }).(pulumi.StringOutput)
}

// This is the sharing type. This attribute can only have values defined one of: `DiskSharing`,`ControllerSharing`, `None`
func (o IndependentDiskOutput) SharingType() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.SharingType }).(pulumi.StringOutput)
}

// size in MB
func (o IndependentDiskOutput) SizeInMb() pulumi.IntOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.IntOutput { return v.SizeInMb }).(pulumi.IntOutput)
}

func (o IndependentDiskOutput) StorageProfile() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.StorageProfile }).(pulumi.StringOutput)
}

// The UUID of this named disk's device backing
func (o IndependentDiskOutput) Uuid() pulumi.StringOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringOutput { return v.Uuid }).(pulumi.StringOutput)
}

// The name of VDC to use, optional if defined at provider level
func (o IndependentDiskOutput) Vdc() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndependentDisk) pulumi.StringPtrOutput { return v.Vdc }).(pulumi.StringPtrOutput)
}

type IndependentDiskArrayOutput struct{ *pulumi.OutputState }

func (IndependentDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskArrayOutput) ToIndependentDiskArrayOutput() IndependentDiskArrayOutput {
	return o
}

func (o IndependentDiskArrayOutput) ToIndependentDiskArrayOutputWithContext(ctx context.Context) IndependentDiskArrayOutput {
	return o
}

func (o IndependentDiskArrayOutput) Index(i pulumi.IntInput) IndependentDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IndependentDisk {
		return vs[0].([]*IndependentDisk)[vs[1].(int)]
	}).(IndependentDiskOutput)
}

type IndependentDiskMapOutput struct{ *pulumi.OutputState }

func (IndependentDiskMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndependentDisk)(nil)).Elem()
}

func (o IndependentDiskMapOutput) ToIndependentDiskMapOutput() IndependentDiskMapOutput {
	return o
}

func (o IndependentDiskMapOutput) ToIndependentDiskMapOutputWithContext(ctx context.Context) IndependentDiskMapOutput {
	return o
}

func (o IndependentDiskMapOutput) MapIndex(k pulumi.StringInput) IndependentDiskOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IndependentDisk {
		return vs[0].(map[string]*IndependentDisk)[vs[1].(string)]
	}).(IndependentDiskOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskInput)(nil)).Elem(), &IndependentDisk{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskArrayInput)(nil)).Elem(), IndependentDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndependentDiskMapInput)(nil)).Elem(), IndependentDiskMap{})
	pulumi.RegisterOutputType(IndependentDiskOutput{})
	pulumi.RegisterOutputType(IndependentDiskArrayOutput{})
	pulumi.RegisterOutputType(IndependentDiskMapOutput{})
}
