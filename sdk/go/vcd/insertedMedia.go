// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vcd

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type InsertedMedia struct {
	pulumi.CustomResourceState

	// catalog name where to find media file
	Catalog pulumi.StringOutput `pulumi:"catalog"`
	// When ejecting answers automatically to question yes
	EjectForce pulumi.BoolPtrOutput `pulumi:"ejectForce"`
	// media name to use
	Name pulumi.StringOutput `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrOutput `pulumi:"org"`
	// vApp to use
	VappName pulumi.StringOutput `pulumi:"vappName"`
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrOutput `pulumi:"vdc"`
	// VM in vApp in which media will be inserted or ejected
	VmName pulumi.StringOutput `pulumi:"vmName"`
}

// NewInsertedMedia registers a new resource with the given unique name, arguments, and options.
func NewInsertedMedia(ctx *pulumi.Context,
	name string, args *InsertedMediaArgs, opts ...pulumi.ResourceOption) (*InsertedMedia, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Catalog == nil {
		return nil, errors.New("invalid value for required argument 'Catalog'")
	}
	if args.VappName == nil {
		return nil, errors.New("invalid value for required argument 'VappName'")
	}
	if args.VmName == nil {
		return nil, errors.New("invalid value for required argument 'VmName'")
	}
	var resource InsertedMedia
	err := ctx.RegisterResource("vcd:index/insertedMedia:InsertedMedia", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInsertedMedia gets an existing InsertedMedia resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInsertedMedia(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InsertedMediaState, opts ...pulumi.ResourceOption) (*InsertedMedia, error) {
	var resource InsertedMedia
	err := ctx.ReadResource("vcd:index/insertedMedia:InsertedMedia", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering InsertedMedia resources.
type insertedMediaState struct {
	// catalog name where to find media file
	Catalog *string `pulumi:"catalog"`
	// When ejecting answers automatically to question yes
	EjectForce *bool `pulumi:"ejectForce"`
	// media name to use
	Name *string `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org *string `pulumi:"org"`
	// vApp to use
	VappName *string `pulumi:"vappName"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
	// VM in vApp in which media will be inserted or ejected
	VmName *string `pulumi:"vmName"`
}

type InsertedMediaState struct {
	// catalog name where to find media file
	Catalog pulumi.StringPtrInput
	// When ejecting answers automatically to question yes
	EjectForce pulumi.BoolPtrInput
	// media name to use
	Name pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrInput
	// vApp to use
	VappName pulumi.StringPtrInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
	// VM in vApp in which media will be inserted or ejected
	VmName pulumi.StringPtrInput
}

func (InsertedMediaState) ElementType() reflect.Type {
	return reflect.TypeOf((*insertedMediaState)(nil)).Elem()
}

type insertedMediaArgs struct {
	// catalog name where to find media file
	Catalog string `pulumi:"catalog"`
	// When ejecting answers automatically to question yes
	EjectForce *bool `pulumi:"ejectForce"`
	// media name to use
	Name *string `pulumi:"name"`
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org *string `pulumi:"org"`
	// vApp to use
	VappName string `pulumi:"vappName"`
	// The name of VDC to use, optional if defined at provider level
	Vdc *string `pulumi:"vdc"`
	// VM in vApp in which media will be inserted or ejected
	VmName string `pulumi:"vmName"`
}

// The set of arguments for constructing a InsertedMedia resource.
type InsertedMediaArgs struct {
	// catalog name where to find media file
	Catalog pulumi.StringInput
	// When ejecting answers automatically to question yes
	EjectForce pulumi.BoolPtrInput
	// media name to use
	Name pulumi.StringPtrInput
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
	// different organizations
	Org pulumi.StringPtrInput
	// vApp to use
	VappName pulumi.StringInput
	// The name of VDC to use, optional if defined at provider level
	Vdc pulumi.StringPtrInput
	// VM in vApp in which media will be inserted or ejected
	VmName pulumi.StringInput
}

func (InsertedMediaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*insertedMediaArgs)(nil)).Elem()
}

type InsertedMediaInput interface {
	pulumi.Input

	ToInsertedMediaOutput() InsertedMediaOutput
	ToInsertedMediaOutputWithContext(ctx context.Context) InsertedMediaOutput
}

func (*InsertedMedia) ElementType() reflect.Type {
	return reflect.TypeOf((**InsertedMedia)(nil)).Elem()
}

func (i *InsertedMedia) ToInsertedMediaOutput() InsertedMediaOutput {
	return i.ToInsertedMediaOutputWithContext(context.Background())
}

func (i *InsertedMedia) ToInsertedMediaOutputWithContext(ctx context.Context) InsertedMediaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsertedMediaOutput)
}

// InsertedMediaArrayInput is an input type that accepts InsertedMediaArray and InsertedMediaArrayOutput values.
// You can construct a concrete instance of `InsertedMediaArrayInput` via:
//
//	InsertedMediaArray{ InsertedMediaArgs{...} }
type InsertedMediaArrayInput interface {
	pulumi.Input

	ToInsertedMediaArrayOutput() InsertedMediaArrayOutput
	ToInsertedMediaArrayOutputWithContext(context.Context) InsertedMediaArrayOutput
}

type InsertedMediaArray []InsertedMediaInput

func (InsertedMediaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InsertedMedia)(nil)).Elem()
}

func (i InsertedMediaArray) ToInsertedMediaArrayOutput() InsertedMediaArrayOutput {
	return i.ToInsertedMediaArrayOutputWithContext(context.Background())
}

func (i InsertedMediaArray) ToInsertedMediaArrayOutputWithContext(ctx context.Context) InsertedMediaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsertedMediaArrayOutput)
}

// InsertedMediaMapInput is an input type that accepts InsertedMediaMap and InsertedMediaMapOutput values.
// You can construct a concrete instance of `InsertedMediaMapInput` via:
//
//	InsertedMediaMap{ "key": InsertedMediaArgs{...} }
type InsertedMediaMapInput interface {
	pulumi.Input

	ToInsertedMediaMapOutput() InsertedMediaMapOutput
	ToInsertedMediaMapOutputWithContext(context.Context) InsertedMediaMapOutput
}

type InsertedMediaMap map[string]InsertedMediaInput

func (InsertedMediaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InsertedMedia)(nil)).Elem()
}

func (i InsertedMediaMap) ToInsertedMediaMapOutput() InsertedMediaMapOutput {
	return i.ToInsertedMediaMapOutputWithContext(context.Background())
}

func (i InsertedMediaMap) ToInsertedMediaMapOutputWithContext(ctx context.Context) InsertedMediaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsertedMediaMapOutput)
}

type InsertedMediaOutput struct{ *pulumi.OutputState }

func (InsertedMediaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InsertedMedia)(nil)).Elem()
}

func (o InsertedMediaOutput) ToInsertedMediaOutput() InsertedMediaOutput {
	return o
}

func (o InsertedMediaOutput) ToInsertedMediaOutputWithContext(ctx context.Context) InsertedMediaOutput {
	return o
}

// catalog name where to find media file
func (o InsertedMediaOutput) Catalog() pulumi.StringOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringOutput { return v.Catalog }).(pulumi.StringOutput)
}

// When ejecting answers automatically to question yes
func (o InsertedMediaOutput) EjectForce() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.BoolPtrOutput { return v.EjectForce }).(pulumi.BoolPtrOutput)
}

// media name to use
func (o InsertedMediaOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across
// different organizations
func (o InsertedMediaOutput) Org() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringPtrOutput { return v.Org }).(pulumi.StringPtrOutput)
}

// vApp to use
func (o InsertedMediaOutput) VappName() pulumi.StringOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringOutput { return v.VappName }).(pulumi.StringOutput)
}

// The name of VDC to use, optional if defined at provider level
func (o InsertedMediaOutput) Vdc() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringPtrOutput { return v.Vdc }).(pulumi.StringPtrOutput)
}

// VM in vApp in which media will be inserted or ejected
func (o InsertedMediaOutput) VmName() pulumi.StringOutput {
	return o.ApplyT(func(v *InsertedMedia) pulumi.StringOutput { return v.VmName }).(pulumi.StringOutput)
}

type InsertedMediaArrayOutput struct{ *pulumi.OutputState }

func (InsertedMediaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InsertedMedia)(nil)).Elem()
}

func (o InsertedMediaArrayOutput) ToInsertedMediaArrayOutput() InsertedMediaArrayOutput {
	return o
}

func (o InsertedMediaArrayOutput) ToInsertedMediaArrayOutputWithContext(ctx context.Context) InsertedMediaArrayOutput {
	return o
}

func (o InsertedMediaArrayOutput) Index(i pulumi.IntInput) InsertedMediaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *InsertedMedia {
		return vs[0].([]*InsertedMedia)[vs[1].(int)]
	}).(InsertedMediaOutput)
}

type InsertedMediaMapOutput struct{ *pulumi.OutputState }

func (InsertedMediaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InsertedMedia)(nil)).Elem()
}

func (o InsertedMediaMapOutput) ToInsertedMediaMapOutput() InsertedMediaMapOutput {
	return o
}

func (o InsertedMediaMapOutput) ToInsertedMediaMapOutputWithContext(ctx context.Context) InsertedMediaMapOutput {
	return o
}

func (o InsertedMediaMapOutput) MapIndex(k pulumi.StringInput) InsertedMediaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *InsertedMedia {
		return vs[0].(map[string]*InsertedMedia)[vs[1].(string)]
	}).(InsertedMediaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InsertedMediaInput)(nil)).Elem(), &InsertedMedia{})
	pulumi.RegisterInputType(reflect.TypeOf((*InsertedMediaArrayInput)(nil)).Elem(), InsertedMediaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InsertedMediaMapInput)(nil)).Elem(), InsertedMediaMap{})
	pulumi.RegisterOutputType(InsertedMediaOutput{})
	pulumi.RegisterOutputType(InsertedMediaArrayOutput{})
	pulumi.RegisterOutputType(InsertedMediaMapOutput{})
}
